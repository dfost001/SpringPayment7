/*
 * To do:
 * Write to persistent storage: verified, error
 * Add related table - if data not changed, and address verified, return show = false
 *
 */
package view.attributes;

import java.util.ArrayList;
import java.util.List;
import javax.servlet.http.HttpSession;
import model.customer.Customer;
import model.customer.PostalAddress;
import model.customer.ShipAddress;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import restAddressService.addressService.SvcAnalysis;
import error_util.EhrLogger;
//import java.text.MessageFormat;
import restAddressService.AjaxRequest;

import util.StringUtil;

/*
 * This component is added to model to show messages generated by the service
 * and evaluation messages generated here.
 * Note: The address that was evaluated is contained in the ajax response object's
 * message fields.
 */
@Component
@Scope("request")
public class AddressSvcResult {
    
    public enum AddressResult {
        Valid,
        Error,
        Warning
    }
        
    @Autowired
    private CustomerAttributes customerAttrs;   
    
    private SvcAnalysis svcAnalysisCustomer; //response object returned to javascript client
    
    private SvcAnalysis svcAnalysisShipAddress;
    
    private List<String> mvcAnalysisCustomer = new ArrayList<>();
    
    private List<String> mvcAnalysisShipToAddress = new ArrayList<>();
    
    private AddressResult addressResultCustomer;
    
    private AddressResult addressResultShipAddress;;
    
    private AddressSvcResult.ViewStyle viewStyle;  
    
    /*
     * disableContinue
     * Initialization is important, because evalSvcResult does not set
     * to false 
     */    
    private boolean disableContinue = false;  //Initialization is important
    
    private final String selectedNotEqualValidated = "<font color='#EA5200'>" +
            "Selected/Submitted address differs from the service return. You may have edited. Please re-verify." +
            "</font>";   
    
    private final String invalidAllEqualReverify = "<font color='#EA5200'>" +
            "Your validated and selected delivery address are equal and not valid. Please edit and re-verify." +
            "</font>";
    
    private final String selectedNotEqualUploaded = "<font color='#EA5200'>" +
            "Your selected/submitted delivery address differs from the uploaded address. You may have revised. "
            + "Please re-verify." +
            "</font>"; //No validated format. Match is null.
    
    private final String uploadedNotEqualValidated = "<font color='#EA5200'>" +
            "Your uploaded address differs from the validated format. You may have edited to valid. "
            + "Please re-verify." +
            "</font>"; //Invalid. Maybe re-verify will change match-code. No example of change.
    
    private final String invalidMessage = "<font color='#EA5200'>" +
            "Your address, as uploaded, is not considered deliverable by the service: " +
            "</font>";
    
     private final String validMessage = "<font color='#006600'>" +
            "Your address has been confirmed by a service. " +
            "</font>";
     
    private final String verificationRequiredMessage = "<font color='#EA5200'>" +
            "Address verification is required to continue." +
            "</font>";
    
    private final String continueWithInvalidMessage = "<font color='#EA5200'>" +
            "Your address is not considered deliverable. You may continue; however, the service strongly recommends that you " +
            "correct the address to ensure deliverability. " +
            "</font>";    
    
    private final String validWarningMessage = "<font color='#EA5200'>" +
            "This is a valid address, but may not be ready for delivery. " +
            "</font>";    
    
    private final String disabledMessage = "<font color='#EA5200'>" +
            "Continue is disabled for this address. Please return to the form and verify." +
            "</font>";   
    
    private final String moreInformationMessage = "<font color='#FF69B4'>" +
            "Please use the drop-down panel to show uploaded, verified, selected address. " +
            "</font>"; 
    
    public boolean isDisableContinue() {
       return disableContinue;
    }
    
    public String getInformationMessage() {
        return moreInformationMessage;
    }

    public ViewStyle getViewStyle() {
        return viewStyle;
    }   

    public SvcAnalysis getSvcAnalysisCustomer() {
        return svcAnalysisCustomer;
    }

    public SvcAnalysis getSvcAnalysisShipAddress() {
        return svcAnalysisShipAddress;
    }

    public List<String> getMvcAnalysisCustomer() {
        return mvcAnalysisCustomer;
    }

    public List<String> getMvcAnalysisShipToAddress() {
        return mvcAnalysisShipToAddress;
    } 

    public AddressResult getAddressResultCustomer() {
        return addressResultCustomer;
    }

    public AddressResult getAddressResultShipAddress() {
        return addressResultShipAddress; 
    }

    public void showAddressSvcResult(Customer customer, PostalAddress selectedAddress,
            HttpSession session ) {
        
         this.handleNullPointers(customer, selectedAddress);       
        
        
        this.svcAnalysisCustomer = customerAttrs.getSvcAnalysis(customer);
        
        this.svcAnalysisShipAddress = customerAttrs.getSvcAnalysis(selectedAddress);      
      
        this.addressResultShipAddress = this.processSvcResult(selectedAddress, svcAnalysisShipAddress,
                this.mvcAnalysisShipToAddress);  
        
        if(Customer.class.isAssignableFrom(selectedAddress.getClass()))
            
            this.addressResultCustomer = addressResultShipAddress;
            
        else {
            this.addressResultCustomer = this.processSvcResult(customer, svcAnalysisCustomer, 
                this.mvcAnalysisCustomer); 
        }        
        viewStyle = this.new ViewStyle();
    }
    /*
     * Bug: Do not set module-level boolean disableContinue to false as it possible
     * to reset a previous evaluation
    */
    private AddressResult processSvcResult(PostalAddress address, SvcAnalysis svcAnalysis,
            List<String> mvcAnalysis) {              
       
       AddressResult  result = null;            
        
        if(svcAnalysis == null) { 
            
            result = AddressResult.Warning;           
            this.disableContinue = true;         
            mvcAnalysis.add(this.verificationRequiredMessage);        
            mvcAnalysis.add(this.disabledMessage);         
            return result;                 
        }           
            
        if(svcAnalysis.getValid()) {   
                
            if(!this.selectedEqualsValidated(svcAnalysis, address)) {
                
                result = AddressResult.Warning;                        
                mvcAnalysis.add(this.selectedNotEqualValidated) ;  
                mvcAnalysis.add(this.disabledMessage);
                this.disableContinue = true;
            }
                
            else if(!StringUtil.isNullOrEmpty(svcAnalysis.getValidWarningMessage())) {
                   
                result = AddressResult.Warning;
                mvcAnalysis.add(this.validWarningMessage);
                mvcAnalysis.add(svcAnalysis.getValidWarningMessage());
                mvcAnalysis.add(this.continueWithInvalidMessage);
            }
            else  { 
                    
                result = AddressResult.Valid;
                mvcAnalysis.add(this.validMessage) ;                       
                        
            } 
            return result;
        } 
        else return processInvalidAnalysis(address, svcAnalysis, mvcAnalysis);       
    }  //end eval
    
     private AddressResult processInvalidAnalysis (PostalAddress address,
        SvcAnalysis svcAnalysis, List<String> mvcAnalysis) {
               
       AddressResult result = AddressResult.Error;  
                
       //mvcAnalysis.add(this.invalidMessage); 
       
       mvcAnalysis.add("<font color='#EA5200'>" +
               svcAnalysis.getSvcMessages().get(0) + "</font>"); //Add first invalid service message 
       
       if(StringUtil.isNullOrEmpty(svcAnalysis.getValidatedStreetLineFormat())) {
           
           mvcAnalysis.add(this.disabledMessage);               
           this.disableContinue = true;
           if(!this.requestedEqualsSelected(svcAnalysis, address)) {
               mvcAnalysis.remove(0);
               mvcAnalysis.add(this.selectedNotEqualUploaded);              
           }
          
       }        
       else if(!this.selectedEqualsValidated(svcAnalysis, address)) {  
            mvcAnalysis.remove(0);         
            this.disableContinue = true;
            mvcAnalysis.add(this.selectedNotEqualValidated); 
            mvcAnalysis.add(this.disabledMessage); 
            
        }
                
        else if(svcAnalysis.getContinueOnInvalid()) {
           
            mvcAnalysis.add(this.continueWithInvalidMessage);
            this.debugPrintMvc(mvcAnalysis);
            
        } else  { //continueOnInvalid is false and selected equals invalid validatedFormat
           
            mvcAnalysis.add(this.invalidAllEqualReverify);
            mvcAnalysis.add(this.disabledMessage);              
            this.disableContinue = true;            
        }
       
       return result;
          
    }
    
    /*
     * Note: If the uploaded address is valid, JavaScript fills in the zipPlus4
     * and the delivery line. 
     * End-user may edit address and not verify. So include these fields.
     * Option: Compare on zip5 only since there may be more than one plus4 accurate value.   
     * Note: Cannot return false if no zipPlus4. May be an EWS match.
     * Lenient: If not valid and equal we will let address pass with warning
     */
    private boolean selectedEqualsValidated(SvcAnalysis svc, 
            PostalAddress postalAddress) {        
       
       String zipResult = svc.getZipPlus4().isEmpty() ? svc.getZip() :
               svc.getZipPlus4();
       
       boolean streetEqual = this.compareSelectedToValidatedStreetFormat(svc, postalAddress);
           
       if(
            streetEqual 
            && svc.getCityId() != null && svc.getCityId() != 0
            && svc.getCityId().equals(postalAddress.getAddressId().getCityId().getCityId())
            && svc.getStateAbbrev().equals(postalAddress.getAddressId().getDistrict())
            && zipResult.equals(postalAddress.getAddressId().getPostalCode())) {
               
               return true;
        }     
        return false;       
    }
    /*
     * Note: If there is no validated format, we want to disable the continue so
     * return false
     */
    private boolean compareSelectedToValidatedStreetFormat(SvcAnalysis svc, PostalAddress address) {
        
        String validCompare = svc.getValidatedStreetLineFormat();
        
        if(StringUtil.isNullOrEmpty(validCompare)) {
            
            EhrLogger.throwIllegalArg(this.getClass().getCanonicalName(),
                   "compareSelectedToValidatedStreetFormat", 
                   "Unexpected: svc#validatedStreetLineFormat is empty");
            
             //return false;     
        }
        String selectedStreet = address.getAddressId().getAddress1();      
        
        return StringUtil.tokenizeAndCompare(validCompare, selectedStreet, false); //ignoreSize->false
    }   
        
    private boolean requestedEqualsValidated(SvcAnalysis svc) {
        
      AjaxRequest request = svc.getAjaxRequest();
        
       String street = request.getStreet();      
       
       String validCompare = svc.getValidatedStreetLineFormat();
        
       if(StringUtil.isNullOrEmpty(validCompare)) {
           
           EhrLogger.throwIllegalArg(this.getClass().getCanonicalName(),
                   "compareValidatedFormatToRequest", 
                   "Unexpected: svc#validatedStreetLineFormat is empty");
             //return false;     
       }
       boolean streetEqual = StringUtil.tokenizeAndCompare(validCompare, street, false); //ignoreSize->false
       
       if(
            streetEqual 
            && svc.getCity().equals(request.getCity())
            && svc.getStateAbbrev().equals(request.getState())
            && svc.getZipPlus4().equals(request.getZipcode()))
           
           return true;  
       
       return false;        
    }  
    
    /*
     * Case comparison should not be a problem: see TextFormatDeserializer
     */
    private boolean requestedEqualsSelected(SvcAnalysis svc, PostalAddress selected) {
        
        AjaxRequest request = svc.getAjaxRequest();       
        
        boolean streetEqual = StringUtil.tokenizeAndCompare(request.getStreet(), 
                selected.getAddressId().getAddress1(), false);
    
       if( streetEqual 
            && selected.getAddressId().getCityId().getCityName().equals(request.getCity())
            && selected.getAddressId().getDistrict().equals(request.getState())
            && selected.getAddressId().getPostalCode().equals(request.getZipcode())) {
           
           return true;
       }
       return false;    
    }
    
   /* private void debugPrint(AjaxRequest request, PostalAddress selected, boolean streetEqual) {
        
        String format = "{0}={1} {2}={3} {4}={5} {6}={7}";
        MessageFormat fmt = new MessageFormat(format);
        String line = fmt.format("Street Equal",streetEqual,
                request.getCity(), selected.getAddressId().getCityId().getCityName(), 
                request.getState()
        
    }*/
    
    private void handleNullPointers(Customer customer, PostalAddress selectedShipAddress) throws IllegalArgumentException{
        
        String msg = "";
        
        
        if(customer == null)
            msg += "Customer is null; ";
        if(selectedShipAddress == null)
            msg += "PostalAddress selectedShipAddress is null";
        
        
        if(!msg.isEmpty())
            throw new IllegalArgumentException(EhrLogger.doError(this.getClass().getCanonicalName(),
                    "handleNullPointers", msg));
             
        
    }
  
    
   private void debugPrintMvc(List<String> mvcAnalysis) {
       System.out.println("AddressSvcResult#debugPrintMvc");
       if(mvcAnalysis.equals(this.mvcAnalysisShipToAddress)) {
              System.out.println("mvcAnalysisShipToAddress");
              this.mvcAnalysisShipToAddress.forEach((s) -> System.out.println(s));
       }
       else {
           System.out.println("mvcAnalysisCustomer");
           this.mvcAnalysisCustomer.forEach((s) -> System.out.println(s));
       }
      
   }
    
    public class ViewStyle {
        
        private final String iconInfo="/resources/images/info-20.png" ;
        
        private  final String iconValid="/resources/images/check-20.png";
        private final String iconError="/resources/images/error-20.png";
        private final String iconWarning="/resources/images/warning-20.png";
        
        private final String panelWarning="panel panel-warning";
        private final String panelError="panel panel-danger";
        private final String panelValid="panel panel-success";
        
        private final String colorWarning="#663300";
        private final String colorValid="#006600";
        private final String colorError="#660000";
        
        private String iconCustomer;
        private String iconShipTo;
        private String panelCustomer;
        private String panelShipTo;
        private String colorCustomer;
        private String colorShipTo;

        public String getIconCustomer() {
            return iconCustomer;
        }

        public String getIconShipTo() {
            return iconShipTo;
        }
        
        public String getIconInfo() {
            return iconInfo ;
        }

        public String getPanelCustomer() {
            return panelCustomer;
        }

        public String getPanelShipTo() {
            return panelShipTo;
        }

        public String getColorShipTo() {
            return colorShipTo;
        }
        
       public String getColorCustomer() {
           return colorCustomer;
       }
       
       public ViewStyle() {
           init();
       }
              
       private void init(){
           
           assignStyle(addressResultCustomer, Customer.class);
          
           assignStyle(addressResultShipAddress, ShipAddress.class);
       }
       
       private void assignStyle(AddressResult result, Class<?> cls) {    
        
        String name = result.name();
        
        switch(name) {  
               
            case "Error" :
                if(Customer.class.isAssignableFrom(cls)){
                    iconCustomer = iconError;
                    colorCustomer = colorError;
                    panelCustomer = panelError;
                }
                else if(ShipAddress.class.isAssignableFrom(cls)){
                    iconShipTo = iconError;
                    colorShipTo = colorError;
                    panelShipTo = panelError;
                }
                break;
            case "Valid":
                if(Customer.class.isAssignableFrom(cls)){
                    iconCustomer = iconValid;
                    colorCustomer = colorValid;
                    panelCustomer = panelValid;
                }
                else if(ShipAddress.class.isAssignableFrom(cls)){
                    iconShipTo = iconValid;
                    colorShipTo = colorValid;
                    panelShipTo = panelValid;
                }
                break;                
            case "Warning":    
                 if(Customer.class.isAssignableFrom(cls)){
                    iconCustomer = iconWarning;
                    colorCustomer = colorWarning;
                    panelCustomer = panelWarning;
                }
                else if(ShipAddress.class.isAssignableFrom(cls)){
                    iconShipTo = iconWarning;
                    colorShipTo = colorWarning;
                    panelShipTo = panelWarning;
                }
                 break;
            default:
                throw new IllegalArgumentException(EhrLogger.doError(
                        this.getClass().getCanonicalName(), "assignStyle", 
                        "AddressResult Enum must contain {Error,Valid,Warning}"));
        }
        
           
        
       }       
    }//end inner class
    
   
    
}//end outer AddressSvcResult
